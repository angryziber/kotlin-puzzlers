Correct answer: **c) interop.singletonInstance.Singleton@4b67cf4d**


According to doc, `object` modifier creates a singleton instance as a static field with name INSTANCE. What if we define
another `INSTANCE` field?

It turned out that it's legal to have same-name fields of different types in a class's bytecode, because their signatures
are still different and JVM always refers to a field as a tuple of name and type. Although you can't write it in Java language.

Let's look into Singleton.class:
```
$ javap -c Singleton.class

public final class interop.singletonInstance.Singleton {
  public static final java.lang.String INSTANCE;

  public static final interop.singletonInstance.Singleton INSTANCE;

  static {};
    Code:
       0: new           #2                  // class interop/singletonInstance/Singleton
       3: invokespecial #34                 // Method "<init>":()V
       6: return
}
```
There are 2 `INSTANCE` fields of different types.


Java compiler picked one of them silently. Which one? - that is the question.
```
$ javap -c SingletonAccessor.class

Compiled from "SingletonAccessor.java"
public class interop.singletonInstance.SingletonAccessor {
  public interop.singletonInstance.SingletonAccessor();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: getstatic     #3                  // Field interop/singletonInstance/Singleton.INSTANCE:Linterop/singletonInstance/Singleton;
       6: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
       9: return
}

```
I don't know the exact rule of choosing the proper field (need to dive into spec), but it seems to pick the last one in
the list (the autogenerated one).

Let's check it: open the Singleton.class file in [Java Bytecode Editor](http://cs.ioc.ee/~ando/jbe/), delete the first
INSTANCE field of String type and add the same field to the end of the list.
```
$ javap -c Singleton.class 

Compiled from "Singleton.kt"
public final class interop.singletonInstance.Singleton {
  public static final interop.singletonInstance.Singleton INSTANCE;

  public static final java.lang.String INSTANCE;
  
  static {};
    Code:
       0: new           #2                  // class interop/singletonInstance/Singleton
       3: invokespecial #34                 // Method "<init>":()V
       6: return
}
``` 

Now re-compile and run `SingletonAccessor`:
```
$ javac interop/singletonInstance/SingletonAccessor.java
$ java interop.singletonInstance.SingletonAccessor 
Hello world!
```

So, the behavior is defined, but not obvious.