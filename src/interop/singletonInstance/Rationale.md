#### SingletonAccessor.java
It prints: `interop.singletonInstance.Singleton@4b67cf4d`

But correct answer is: **d) Undefined behavior**

According to the documentation, `object` modifier creates a singleton instance as a static field with name INSTANCE. What
if we define another `INSTANCE` field?

It turned out that the JVM specification doesn't forbid having same-name fields of different types in a class's bytecode,
because their signatures are still different and JVM always refers to a field as a tuple of name and type. Although you
can't write it in Java language according to the spec:

> ยง8.3 Field declaration  
> ...  
> It is a compile-time error for the body of a class declaration to declare two fields with the same name.


Let's look into Singleton.class:
```
$ javap -c Singleton.class

public final class interop.singletonInstance.Singleton {
  public static final java.lang.String INSTANCE;

  public static final interop.singletonInstance.Singleton INSTANCE;

  static {};
    Code:
       0: new           #2                  // class interop/singletonInstance/Singleton
       3: invokespecial #34                 // Method "<init>":()V
       6: return
}
```
There are 2 `INSTANCE` fields of different types.


Java compiler picked one of them silently. Which one? - that is the question.
```
$ javap -c SingletonAccessor.class

Compiled from "SingletonAccessor.java"
public class interop.singletonInstance.SingletonAccessor {
  public interop.singletonInstance.SingletonAccessor();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: getstatic     #3                  // Field interop/singletonInstance/Singleton.INSTANCE:Linterop/singletonInstance/Singleton;
       6: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
       9: return
}

```
Java compiler seems to pick the last field in the list (the autogenerated one).

Let's check it: open the Singleton.class file in [Java Bytecode Editor](http://cs.ioc.ee/~ando/jbe/), delete the first
INSTANCE field of String type and add the same field to the end of the list.
```
$ javap -c Singleton.class 

Compiled from "Singleton.kt"
public final class interop.singletonInstance.Singleton {
  public static final interop.singletonInstance.Singleton INSTANCE;

  public static final java.lang.String INSTANCE;
  
  static {};
    Code:
       0: new           #2                  // class interop/singletonInstance/Singleton
       3: invokespecial #34                 // Method "<init>":()V
       6: return
}
``` 

Now re-compile and run `SingletonAccessor.java`:
```
$ javac interop/singletonInstance/SingletonAccessor.java
$ java interop.singletonInstance.SingletonAccessor 
Hello world!
```

So, the compiler picks the last field indeed, but this is out of scope of the Java Language spec, so the behavior seems
to be undefined.


#### SingletonAccessor.kt
Correct answer: **b) Hello world!**

Kotlin compiler doesn't see the autogenerated INSTANCE field of Singleton type. The correct way to refer to Singleton
instance is just `Singleton`. So the behavior is defined.