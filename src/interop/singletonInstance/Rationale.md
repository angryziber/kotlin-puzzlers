Correct answer: **c) interop.singletonInstance.Singleton@4b67cf4d**


According to doc, `object` modifier creates a singleton instance as a static field with name INSTANCE. What if we define
another `INSTANCE` field?

It turned out that it's legal to have same-name fields of different types in a class's bytecode, because their signatures
are still different. Although you can't write it in Java language.

Let's look into Singleton.class:
```
$ javap -c Singleton.class

public final class interop.singletonInstance.Singleton {
  public static final java.lang.String INSTANCE;

  public static final interop.singletonInstance.Singleton INSTANCE;

  static {};
    Code:
       0: new           #2                  // class interop/singletonInstance/Singleton
       3: invokespecial #34                 // Method "<init>":()V
       6: return
}
```
There are 2 `INSTANCE` fields of different types.


Java compiler picked one of them silently.
```
$ javap -c SingletonAccessor.class

Compiled from "SingletonAccessor.java"
public class interop.singletonInstance.SingletonAccessor {
  public interop.singletonInstance.SingletonAccessor();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: getstatic     #3                  // Field interop/singletonInstance/Singleton.INSTANCE:Linterop/singletonInstance/Singleton;
       6: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
       9: return
}

```
I still don't know how it chose one of two fields.

**NB** this declaration doesn't work: `@JvmField var INSTANCE: Singleton?`, because its signature clashes with the autogenerated field.
